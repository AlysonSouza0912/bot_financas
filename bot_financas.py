# -*- coding: utf-8 -*-
"""bot_financas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UsSJCTOuDF3vggEhUhxwmjCCKLimzttW
"""

!pip install python-telegram-bot --upgrade

!pip install nest_asyncio

!pip install pandas

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes
import pandas as pd
import os
import nest_asyncio
from datetime import datetime
import re

TOKEN = '8089759783:AAEyWdIffZu6YoGebsuqfE-6witS61csF6Y'
ARQUIVO = 'gastos.csv'

# FunÃ§Ã£o para detectar categoria
def detectar_categoria(msg):
    msg = msg.lower()
    categorias = {
        'Mercado': ['mercado', 'supermercado', 'compras'],
        'AlimentaÃ§Ã£o': ['restaurante', 'lanche', 'comida', 'almoÃ§o', 'jantar'],
        'Transporte': ['uber', 'gasolina', 'Ã´nibus', 'metrÃ´'],
        'Lazer': ['cinema', 'festa', 'bar', 'show'],
        'Contas': ['luz', 'Ã¡gua', 'internet', 'aluguel'],
        'Receita': ['recebi', 'salÃ¡rio', 'ganhei']
    }
    for categoria, palavras in categorias.items():
        for palavra in palavras:
            if palavra in msg:
                return categoria
    return 'Outros'

# FunÃ§Ã£o para salvar o gasto
def salvar_gasto(user, message):
    data = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    categoria = detectar_categoria(message)
    novo_registro = {
        'Usuario': user,
        'DataHora': data,
        'Mensagem': message,
        'Categoria': categoria
    }
    if os.path.exists(ARQUIVO):
        df = pd.read_csv(ARQUIVO)
        df = pd.concat([df, pd.DataFrame([novo_registro])], ignore_index=True)
    else:
        df = pd.DataFrame([novo_registro])
    df.to_csv(ARQUIVO, index=False)

# FunÃ§Ã£o para extrair valor - agora soma todos os nÃºmeros da mensagem
def extrair_valor(msg):
    valores = re.findall(r'\d+(?:[.,]\d+)?', msg)
    total = 0
    for v in valores:
        total += float(v.replace(',', '.'))
    return total

# /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('OlÃ¡! Sou seu bot de finanÃ§as. Me envie seus gastos!')

# /saldo
async def saldo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not os.path.exists(ARQUIVO):
        await update.message.reply_text("Nenhum gasto registrado ainda.")
        return
    user = update.message.from_user.username or str(update.message.from_user.id)
    df = pd.read_csv(ARQUIVO)
    df_user = df[df['Usuario'] == user]

    total_receitas = 0
    total_despesas = 0

    for _, row in df_user.iterrows():
        valor = extrair_valor(row['Mensagem'])
        if row['Categoria'] == 'Receita':
            total_receitas += valor
        elif row['Categoria'] != 'Outros':
            total_despesas += valor

    saldo_total = total_receitas - total_despesas

    resposta = (
        f"ğŸ“Š Seu saldo aproximado:\n\n"
        f"ğŸ’° Total de Receitas: R$ {total_receitas:.2f}\n"
        f"ğŸ’¸ Total de Despesas: R$ {total_despesas:.2f}\n"
        f"ğŸ§¾ Saldo Final: R$ {saldo_total:.2f}"
    )

    await update.message.reply_text(resposta)

# /relatorio
async def relatorio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not os.path.exists(ARQUIVO):
        await update.message.reply_text("Nenhum gasto registrado ainda.")
        return
    user = update.message.from_user.username or str(update.message.from_user.id)
    df = pd.read_csv(ARQUIVO)
    df_user = df[df['Usuario'] == user]

    categorias_totais = {}

    for _, row in df_user.iterrows():
        valor = extrair_valor(row['Mensagem'])
        if valor > 0:
            categorias_totais[row['Categoria']] = categorias_totais.get(row['Categoria'], 0) + valor

    if not categorias_totais:
        await update.message.reply_text("Nenhum valor numÃ©rico encontrado nas suas mensagens.")
        return

    resposta = "ğŸ“‹ *Resumo por Categoria:*\n\n"
    for categoria, total in categorias_totais.items():
        resposta += f"ğŸ”¸ {categoria}: R$ {total:.2f}\n"

    await update.message.reply_text(resposta, parse_mode='Markdown')

# /relatorio_mes
async def relatorio_mes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not os.path.exists(ARQUIVO):
        await update.message.reply_text("Nenhum gasto registrado ainda.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Use o comando assim: /relatorio_mes 06/2025")
        return

    user = update.message.from_user.username or str(update.message.from_user.id)
    periodo = context.args[0]
    try:
        mes, ano = periodo.split('/')
    except:
        await update.message.reply_text("Formato incorreto. Use: /relatorio_mes 06/2025")
        return

    df = pd.read_csv(ARQUIVO)
    df_user = df[df['Usuario'] == user]

    df_user['DataHora'] = pd.to_datetime(df_user['DataHora'], errors='coerce')
    df_user = df_user[(df_user['DataHora'].dt.month == int(mes)) & (df_user['DataHora'].dt.year == int(ano))]

    categorias_totais = {}

    for _, row in df_user.iterrows():
        valor = extrair_valor(row['Mensagem'])
        if valor > 0:
            categorias_totais[row['Categoria']] = categorias_totais.get(row['Categoria'], 0) + valor

    if not categorias_totais:
        await update.message.reply_text("Nenhum valor encontrado nesse mÃªs.")
        return

    resposta = f"ğŸ“† Resumo de {mes}/{ano}:\n\n"
    for categoria, total in categorias_totais.items():
        resposta += f"ğŸ”¸ {categoria}: R$ {total:.2f}\n"

    await update.message.reply_text(resposta)

# /relatorio_ano
async def relatorio_ano(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not os.path.exists(ARQUIVO):
        await update.message.reply_text("Nenhum gasto registrado ainda.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Use o comando assim: /relatorio_ano 2025")
        return

    user = update.message.from_user.username or str(update.message.from_user.id)
    ano = context.args[0]

    df = pd.read_csv(ARQUIVO)
    df_user = df[df['Usuario'] == user]

    df_user['DataHora'] = pd.to_datetime(df_user['DataHora'], errors='coerce')
    df_user = df_user[df_user['DataHora'].dt.year == int(ano)]

    categorias_totais = {}

    for _, row in df_user.iterrows():
        valor = extrair_valor(row['Mensagem'])
        if valor > 0:
            categorias_totais[row['Categoria']] = categorias_totais.get(row['Categoria'], 0) + valor

    if not categorias_totais:
        await update.message.reply_text("Nenhum valor encontrado nesse ano.")
        return

    resposta = f"ğŸ“† Resumo Anual {ano}:\n\n"
    for categoria, total in categorias_totais.items():
        resposta += f"ğŸ”¸ {categoria}: R$ {total:.2f}\n"

    await update.message.reply_text(resposta)

# /limpar
async def limpar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not os.path.exists(ARQUIVO):
        await update.message.reply_text("Nenhum gasto registrado ainda.")
        return

    user = update.message.from_user.username or str(update.message.from_user.id)
    df = pd.read_csv(ARQUIVO)
    df = df[df['Usuario'] != user]
    df.to_csv(ARQUIVO, index=False)

    await update.message.reply_text("Seus registros foram apagados com sucesso! ğŸ—‘ï¸")

# Lidando com mensagens normais (nÃ£o comandos)
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user.username or str(update.message.from_user.id)
    message = update.message.text
    salvar_gasto(user, message)
    await update.message.reply_text(f"Gasto recebido e salvo! âœ…")

# ConfiguraÃ§Ã£o do bot
app = ApplicationBuilder().token(TOKEN).build()

app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("saldo", saldo))
app.add_handler(CommandHandler("relatorio", relatorio))
app.add_handler(CommandHandler("relatorio_mes", relatorio_mes))
app.add_handler(CommandHandler("relatorio_ano", relatorio_ano))
app.add_handler(CommandHandler("limpar", limpar))
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

nest_asyncio.apply()

print("Bot financeiro multiusuÃ¡rio rodando...")

await app.run_polling()

